\ProvidesExplFile{ztikz.library.wolfram.tex}{2025/05/17}{1.0.0}{wolfram~library~for~ztikz}



% ==> init variables
\RequirePackage{xsimverb}
\ztool_shell_mkdir:n {ztikz_output/mma_data/}
\tl_const:Nn \g__ztikz_wolfram_path_tl {ztikz_output/mma_data}
\tl_new:N \l__ztikz_wolfram_tmp_arg_tl
\tl_new:N \l__ztikz_wolfram_tmp_res_tl
\seq_new:N \l__ztikz_wolfram_tmp_res_seq
\int_new:N   \g__ztikz_wolfram_text_index_int
\int_new:N   \g__ztikz_wolfram_picture_index_int
\int_gadd:Nn \g__ztikz_wolfram_text_index_int {1}
\int_gadd:Nn \g__ztikz_wolfram_picture_index_int {1}
\ior_new:N \g__ztikz_wolfram_ior 
\iow_new:N \g__ztikz_wolfram_iow
\cs_generate_variant:Nn \xsim_file_write_start:nn {ne}


% ==> core function
\cs_new:Npn \__ztikz_wolfram_tmp_file_handle:n #1
  {
    \edef\@wolfram@tmp@file{\g__ztikz_wolfram_path_tl/t@mp} 
    \tl_if_empty:eF {#1}{
      \iow_open:Ne \g__ztikz_wolfram_iow { \@wolfram@tmp@file.wls }
      \iow_now:Ne \g__ztikz_wolfram_iow { #1 }
      \iow_close:N \g__ztikz_wolfram_iow
    }
    \file_get_mdfive_hash:nN {\@wolfram@tmp@file.wls} \l__ztikz_current_hash_tl
    \xdef\wolfram@tmp@file{\g__ztikz_wolfram_path_tl/\l__ztikz_current_hash_tl}
    \ztool_shell_mv:ee {\@wolfram@tmp@file.wls}{\wolfram@tmp@file.wls}
  }
\cs_new_protected:Npn \__ztikz_wolfram_excute:nnn #1#2#3
  {% #1:contents(empty->not add); #2:extension; #3: output object
    \bool_if:NT \g__ztikz_hashchg_norun_bool
      { 
        \prg_map_break:Nn \l__hashchg_norun_flag {} 
      }
    \__ztikz_wolfram_tmp_file_handle:n {#1}
    \ztool_append_to_file:ee {\wolfram@tmp@file.wls}{Export["\wolfram@tmp@file.#2", #3]}
    \int_gadd:Nn \g__ztikz_wolfram_text_index_int {1}
    \ztikz_hash_if_change:neTF { \c_false_bool }{ \l__ztikz_current_hash_tl }   
      {
        \edef\wolfram@cmd
          {
            \g__ztikz_wolfram_engine_tl\space
            \bool_if:NT \g__ztikz_wolfram_cloud_bool {-cloud\space}
            -script\space
            \wolfram@tmp@file.wls 
          }
        \ztikz_term_info:e 
          {
            \g__ztikz_wolfram_engine_tl\space~is~running~on:'\wolfram@tmp@file.wls'
            ...\iow_newline:
          }
        \ztool_shell_escape:e { \wolfram@cmd }
      }{
        \ztikz_term_info:e {Use~cache~result:'\wolfram@tmp@file.#2'\iow_newline:}
      }
    \xdef\wolframOuputFile{\wolfram@tmp@file.#2}
    \prg_break_point:Nn \l__hashchg_norun_flag 
      { \bool_gset_false:N \g__ztikz_hashchg_norun_bool }
  }
\cs_generate_variant:Nn \__ztikz_wolfram_excute:nnn { e, o }


% ==> user interface
% load result
\NewDocumentCommand\wolframResult{so}
  {
    \ior_open:Ne \g__ztikz_wolfram_ior {\wolfram@tmp@file.txt}
    \ior_get:NN  \g__ztikz_wolfram_ior \l__ztikz_wolfram_tmp_res_tl
    \seq_set_split:NnV \l__ztikz_wolfram_tmp_res_seq {@} \l__ztikz_wolfram_tmp_res_tl
    \IfBooleanTF{#1}
      {% must be integer expression, or it will raise bug.
        \seq_item:Ne \l__ztikz_wolfram_tmp_res_seq 
          {\IfValueTF {#2}{\fp_eval:n {#2}}{1}}
      }
      { \seq_use:Nn \l__ztikz_wolfram_tmp_res_seq {\IfValueTF {#2}{#2}{,}}}
    \ior_close:N \g__ztikz_wolfram_ior
  }

% wolfram graphicx
\NewDocumentEnvironment{wolframGraphics}{O{}}
  {
    \gdef\graphics@dimen{#1}
    \xsim_file_write_start:ne {\c_false_bool}{\g__ztikz_wolfram_path_tl/t@mp.wls}
  }{ 
    \xsim_file_write_stop:  
    \__ztikz_wolfram_excute:nnn {}{pdf}{FIGURE}
    \tl_if_empty:eF {\graphics@dimen}
      {
        \exp_after:wN \includegraphics \exp_after:wN 
          [\graphics@dimen]{\wolfram@tmp@file.pdf}
      }
    \int_gadd:Nn \g__ztikz_wolfram_picture_index_int {1} 
  }

% wolfram simple code
\NewDocumentCommand\wolfram{sm}
  {
    \__ztikz_wolfram_excute:enn
      {
        \IfBooleanTF{#1}
          { TeXResult = ToString[#2]; }
          { TeXResult = ToString[TeXForm[#2]]; }
      }{txt}{TeXResult}
  }

% wolfram tex code(expandable token replace)
\group_begin:
  \char_set_catcode_escape:n { 36 }
  \char_set_catcode_letter:n { 92 }
  $cs_gset:Nn $__double_backslash:n 
    { $tl_if_eq:NNTF #1\ {\\}{#1} }
  $gdef$wolframTex{
    $char_set_catcode_letter:n { 92 }
    $wolframTex@getarg
  }
  $gdef$wolframTex@getarg#1{
    $tl_set:Ne $l_tmpa_tl 
      {
        $tl_map_function:nN {#1}                            
          $__double_backslash:n
      }
    $__ztikz_wolfram_excute:onn
      {TeXResult = TeXForm[ToExpression["$l_tmpa_tl", TeXForm]]}
      {txt}{TeXResult}
    $char_set_catcode_escape:n { 92 }
  }
  $char_set_catcode_escape:n { 92 }
  $char_set_catcode_letter:n { 36 }
\group_end:

% equation solve
\ztikz_keys_define:nn { wolfram/solve }
  {
    var     .tl_set:N  = \l__ztikz_wolfram_var_tl,
    var     .initial:n = {},
    domain  .tl_set:N  = \l__ztikz_wolfram_domain_tl,
    domain  .initial:n = {},
  }
\NewDocumentCommand\wolframSolve{som}
  {
    \group_begin:
    \IfValueT {#2} { \ztikz_keys_set:nn { wolfram/solve } {#2} }
    \tl_if_empty:VF \l__ztikz_wolfram_domain_tl
      { \tl_set:Ne \l__ztikz_wolfram_tmp_arg_tl {,\l__ztikz_wolfram_domain_tl} }
    \__ztikz_wolfram_excute:enn 
      {
        \IfBooleanTF {#1}{
          TeXResult = Row[Solve[#3]//Flatten, "@"]
                    /.{Rule -> Equal}//TeXForm//ToString;
        }{
          TeXResult = Row[
            Solve[#3, {\l__ztikz_wolfram_var_tl} \l__ztikz_wolfram_tmp_arg_tl]//Flatten, 
            "@" 
          ]/.{Rule -> Equal}//TeXForm//ToString;
        }
      }{txt}{TeXResult}
    \group_end:
  }

% differential equation solve
\ztikz_keys_define:nn { wolfram/dsolve }
  {
    depend    .tl_set:N  = \l__ztikz_wolfram_de_var_tl,
    depend    .initial:n = { y[x] },
    independ  .tl_set:N  = \l__ztikz_wolfram_in_var_tl,
    independ  .initial:n = { x },
  }
\NewDocumentCommand\wolframDSolve{som}
  {
    \group_begin:
    \IfValueT {#2} { \ztikz_keys_set:nn { wolfram/dsolve } {#2} }
    \tl_if_empty:VF \l__ztikz_wolfram_in_var_tl
      { \tl_set:Ne \l__ztikz_wolfram_in_var_tl {,\l__ztikz_wolfram_in_var_tl} }
    \__ztikz_wolfram_excute:enn 
      {
        \IfBooleanTF {#1}{
          TeXResult = Row[DSolve[#3]//Flatten, ","]
                    /.{Rule -> Equal}//TeXForm//ToString;
        }{
          TeXResult = Row[
            DSolve[{#3}, {\l__ztikz_wolfram_de_var_tl}\l__ztikz_wolfram_in_var_tl]//Flatten, 
            "@"
          ]/.{Rule -> Equal}//TeXForm//ToString;
        }
      }{txt}{TeXResult}
    \group_end:
  }

% any wolfram/mathics code
\NewDocumentEnvironment{wolframAny}{m}
  {
    \cs_seq_eq:NN \NewLine \iow_newline:
    \cs_set_eq:NN \PrefixPath \g__ztikz_wolfram_path_tl
    \__ztikz_wolfram_excute:nne 
      {}{}{}
  }{
    \cs_seq_eq:NN \NewLine \scan_stop:
    \cs_set_eq:NN \PrefixPath \scan_stop:
  }

% check if integer
\prg_new_protected_conditional:Npnn \__ztikz_if_int:n #1 { T, F, TF }
  {
    \regex_match:nnTF { ^[\+\-]?[\d]+$ } {#1} 
      { \prg_return_true: }
      { \prg_return_false: }
  }
\prg_generate_conditional_variant:Nnn \__ztikz_if_int:n { e } { T, F, TF }