\ProvidesExplFile{ztikz.library.wolfram.tex}{2024/12/17}{1.0.0}{wolfram~library~for~ztikz}



% ==> init variables
\RequirePackage{xsimverb}
\ztool_shell_mkdir:n {ztikz_output/mma_data/}
\tl_const:Nn \g__ztikz_wolfram_path_tl {ztikz_output/mma_data}
\tl_new:N \l__ztikz_wolfram_tmp_arg_tl
\tl_new:N \l__ztikz_wolfram_tmp_res_tl
\seq_new:N \l__ztikz_wolfram_tmp_res_seq
\int_new:N   \g__ztikz_wolfram_text_index_int
\int_new:N   \g__ztikz_wolfram_picture_index_int
\int_gadd:Nn \g__ztikz_wolfram_text_index_int {1}
\int_gadd:Nn \g__ztikz_wolfram_picture_index_int {1}
\ior_new:N \g__ztikz_wolfram_ior 
\iow_new:N \g__ztikz_wolfram_iow
\cs_generate_variant:Nn \xsim_file_write_start:nn {ne}


% ==> core function
\cs_new:Npn \__ztikz_wolfram_tmp_file_handle:n #1
  {
    \edef\@wolfram@tmp@file{\g__ztikz_wolfram_path_tl/t@mp} 
    \tl_if_empty:eF {#1}{
      \iow_open:Ne \g__ztikz_wolfram_iow { \@wolfram@tmp@file.wls }
      \iow_now:Ne \g__ztikz_wolfram_iow { #1 }
      \iow_close:N \g__ztikz_wolfram_iow
    }
    \file_get_mdfive_hash:nN {\@wolfram@tmp@file.wls} \l__ztikz_current_hash_tl
    \xdef\wolfram@tmp@file{\g__ztikz_wolfram_path_tl/\l__ztikz_current_hash_tl}
    \ztool_shell_mv:ee {\@wolfram@tmp@file.wls}{\wolfram@tmp@file.wls}
  }
\cs_new_protected:Npn \__ztikz_wolfram_excute:nnn #1#2#3
  {% #1:contents(empty->not add); #2:extension; #3: output object
    \__ztikz_wolfram_tmp_file_handle:n {#1}
    \ztool_append_to_file:ee {\wolfram@tmp@file.wls}{Export["\wolfram@tmp@file.#2", #3]}
    \int_gadd:Nn \g__ztikz_wolfram_text_index_int {1}
    \ztikz_hash_if_change:neTF { \c_false_bool }{ \l__ztikz_current_hash_tl }   
      {
        \ztool_shell_escape:e { wolframscript~ -script~ \wolfram@tmp@file.wls }
        \ztikz_term_info:e {Wolfram~is~running~on:'\wolfram@tmp@file.wls'...\iow_newline:}
      }{
        \ztikz_term_info:e {Use~cache~result:'\wolfram@tmp@file.#2'\iow_newline:}
      }
    \xdef\wolframOuputFile{\wolfram@tmp@file.#2}
  }
\cs_generate_variant:Nn \__ztikz_wolfram_excute:nnn { e }
% TODO: 
% 1. implement environment 'wolframAny'
% 2. Remove redundant cache file
\NewDocumentEnvironment{wolframAny}{m}
  {
    \cs_seq_eq:NN \NewLine \iow_newline:
    \cs_set_eq:NN \PrefixPath \g__ztikz_wolfram_path_tl
    \__ztikz_wolfram_excute:e 
      {#1}
  }{
    \cs_seq_eq:NN \NewLine \prg_do_nothing: % \scan_stop:
    \cs_set_eq:NN \Path \c_empty_tl
  }


% ==> user interface
% load result
\NewDocumentCommand\wolframResult{so}
  {
    \ior_open:Ne \g__ztikz_wolfram_ior {\wolfram@tmp@file.txt}
    \ior_get:NN  \g__ztikz_wolfram_ior \l__ztikz_wolfram_tmp_res_tl
    \seq_set_split:NnV \l__ztikz_wolfram_tmp_res_seq {@} \l__ztikz_wolfram_tmp_res_tl
    \IfBooleanTF{#1}
      {
        \__ztikz_if_int:eTF {\IfValueTF {#2}{#2}{1}}
          {\seq_item:Ne \l__ztikz_wolfram_tmp_res_seq {\IfValueTF {#2}{#2}{1}}}
          {\fbox{Index~Invalid}}
      }
      { \seq_use:Nn \l__ztikz_wolfram_tmp_res_seq {\IfValueTF {#2}{#2}{,}}}
    \ior_close:N \g__ztikz_wolfram_ior
  }
% wolfram graphicx
\NewDocumentEnvironment{wolframGraphics}{O{}}
  {
    \gdef\graphics@dimen{#1}
    \xsim_file_write_start:ne {\c_false_bool}{\g__ztikz_wolfram_path_tl/t@mp.wls}
  }{ 
    \xsim_file_write_stop:  
    \__ztikz_wolfram_excute:nnn {}{pdf}{FIGURE}
    \tl_if_empty:eF {\graphics@dimen}
      {
        \exp_after:wN \includegraphics \exp_after:wN 
          [\graphics@dimen]{\wolfram@tmp@file.pdf}
      }
    \int_gadd:Nn \g__ztikz_wolfram_picture_index_int {1} 
  }
\NewDocumentCommand\wolfram{sm}
  {
    \__ztikz_wolfram_excute:enn
      {
        \IfBooleanTF{#1}
          { TeXResult = ToString[#2]; }
          { TeXResult = ToString[TeXForm[#2]]; }
      }{txt}{TeXResult}
  }
% equation solve
\ztikz_keys_define:nn { wolfram/solve }
  {
    var     .tl_set:N  = \l__ztikz_wolfram_var_tl,
    var     .initial:n = {},
    domain  .tl_set:N  = \l__ztikz_wolfram_domain_tl,
    domain  .initial:n = {},
  }
\NewDocumentCommand\wolframSolve{som}
  {
    \group_begin:
    \IfValueT {#2} { \ztikz_keys_set:nn { wolfram/solve } {#2} }
    \tl_if_empty:VF \l__ztikz_wolfram_domain_tl
      { \tl_set:Ne \l__ztikz_wolfram_tmp_arg_tl {,\l__ztikz_wolfram_domain_tl} }
    \__ztikz_wolfram_excute:enn 
      {
        \IfBooleanTF {#1}{
          TeXResult = Row[Solve[#3]//Flatten, "@"]
                    /.{Rule -> Equal}//TeXForm//ToString;
        }{
          TeXResult = Row[
            Solve[#3, {\l__ztikz_wolfram_var_tl} \l__ztikz_wolfram_tmp_arg_tl]//Flatten, 
            "@" 
          ]/.{Rule -> Equal}//TeXForm//ToString;
        }
      }{txt}{TeXResult}
    \group_end:
  }
% differential equation solve
\ztikz_keys_define:nn { wolfram/dsolve }
  {
    depend    .tl_set:N  = \l__ztikz_wolfram_de_var_tl,
    depend    .initial:n = { y[x] },
    independ  .tl_set:N  = \l__ztikz_wolfram_in_var_tl,
    independ  .initial:n = { x },
  }
\NewDocumentCommand\wolframDSolve{som}
  {
    \group_begin:
    \IfValueT {#2} { \ztikz_keys_set:nn { wolfram/dsolve } {#2} }
    \tl_if_empty:VF \l__ztikz_wolfram_in_var_tl
      { \tl_set:Ne \l__ztikz_wolfram_in_var_tl {,\l__ztikz_wolfram_in_var_tl} }
    \__ztikz_wolfram_excute:enn 
      {
        \IfBooleanTF {#1}{
          TeXResult = Row[DSolve[#3]//Flatten, ","]
                    /.{Rule -> Equal}//TeXForm//ToString;
        }{
          TeXResult = Row[
            DSolve[{#3}, {\l__ztikz_wolfram_de_var_tl}\l__ztikz_wolfram_in_var_tl]//Flatten, 
            "@"
          ]/.{Rule -> Equal}//TeXForm//ToString;
        }
      }{txt}{TeXResult}
    \group_end:
  }
% check if integer
\prg_new_protected_conditional:Npnn \__ztikz_if_int:n #1 { T, F, TF }
  {
    \regex_match:nnTF { ^[\+\-]?[\d]+$ } {#1} 
      { \prg_return_true: }
      { \prg_return_false: }
  }
\prg_generate_conditional_variant:Nnn \__ztikz_if_int:n { e } { T, F, TF }